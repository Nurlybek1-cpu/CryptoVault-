# SHA-256 (Secure Hash Algorithm 256-bit)

## Overview

**SHA-256** is a cryptographic hash function that produces a 256-bit (32-byte) hash value from input of any size. It is part of the SHA-2 family designed by the NSA and is one of the most widely used hash functions in cryptography today.

## Purpose

- **Data Integrity**: Verify data hasn't been modified
- **Digital Signatures**: Hash messages before signing
- **Password Storage**: Hash passwords (with salt + iterations)
- **Blockchain**: Bitcoin mining, transaction IDs
- **File Verification**: Checksums for downloads

## Algorithm Specification

### Parameters

| Property | Value |
|----------|-------|
| **Input** | Any size (< 2^64 bits) |
| **Output** | 256 bits (32 bytes, 64 hex characters) |
| **Block Size** | 512 bits (64 bytes) |
| **Word Size** | 32 bits |
| **Rounds** | 64 |
| **Security** | 128-bit (2^128 operations) |

### Hash Properties

1. **Deterministic**: Same input always produces same output
2. **Fast Computation**: Quick to calculate hash
3. **Pre-image Resistance**: Cannot find input from hash
4. **Second Pre-image Resistance**: Cannot find different input with same hash
5. **Collision Resistance**: Hard to find two inputs with same hash
6. **Avalanche Effect**: Small input change → large output change

## How SHA-256 Works

### Step-by-Step Process

**1. Message Padding**

```
Original message M
Append bit '1'
Append k bits '0' where k = smallest value such that:
    (length + 1 + k) ≡ 448 (mod 512)
Append 64-bit big-endian length of M

Result: Message length is multiple of 512 bits
```

Example:
```
Message: "abc" (24 bits)
Binary: 01100001 01100010 01100011
Padded: 01100001 01100010 01100011 1 000...000 | 0000...011000
        ←─ abc ─→ 1 ←─ 423 zeros ─→     ←─ length=24 ─→
```

**2. Initialize Hash Values**

```python
H0 = 0x6a09e667
H1 = 0xbb67ae85
H2 = 0x3c6ef372
H3 = 0xa54ff53a
H4 = 0x510e527f
H5 = 0x9b05688c
H6 = 0x1f83d9ab
H7 = 0x5be0cd19
```

(These are first 32 bits of fractional parts of square roots of first 8 primes)

**3. Initialize Round Constants K**

```python
K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    ... (64 constants total)
]
```

(First 32 bits of fractional parts of cube roots of first 64 primes)

**4. Process Each 512-bit Block**

For each 512-bit message block:

a) **Create Message Schedule W[0...63]**:
```
W[0] to W[15] = 16 words of current block

For t = 16 to 63:
    σ0 = (W[t-15] >>> 7) ⊕ (W[t-15] >>> 18) ⊕ (W[t-15] >> 3)
    σ1 = (W[t-2] >>> 17) ⊕ (W[t-2] >>> 19) ⊕ (W[t-2] >> 10)
    W[t] = W[t-16] + σ0 + W[t-7] + σ1
```

b) **Initialize working variables**:
```
a = H0, b = H1, c = H2, d = H3
e = H4, f = H5, g = H6, h = H7
```

c) **64 Rounds of Processing**:
```
For t = 0 to 63:
    Σ1 = (e >>> 6) ⊕ (e >>> 11) ⊕ (e >>> 25)
    Ch = (e ∧ f) ⊕ (¬e ∧ g)
    T1 = h + Σ1 + Ch + K[t] + W[t]

    Σ0 = (a >>> 2) ⊕ (a >>> 13) ⊕ (a >>> 22)
    Maj = (a ∧ b) ⊕ (a ∧ c) ⊕ (b ∧ c)
    T2 = Σ0 + Maj

    h = g
    g = f
    f = e
    e = d + T1
    d = c
    c = b
    b = a
    a = T1 + T2
```

d) **Update Hash Values**:
```
H0 = H0 + a
H1 = H1 + b
H2 = H2 + c
H3 = H3 + d
H4 = H4 + e
H5 = H5 + f
H6 = H6 + g
H7 = H7 + h
```

**5. Final Hash**

```
Hash = H0 || H1 || H2 || H3 || H4 || H5 || H6 || H7
(Concatenate all 8 hash values to get 256-bit result)
```

## Implementation Example

### Python Implementation

```python
import hashlib

def sha256_simple(message):
    """Simple SHA-256 using hashlib"""
    if isinstance(message, str):
        message = message.encode('utf-8')

    hash_object = hashlib.sha256(message)
    return hash_object.hexdigest()

# Usage
message = "Hello, World!"
hash_value = sha256_simple(message)
print(f"SHA-256('{message}') = {hash_value}")

# File hashing
def sha256_file(filename):
    """Compute SHA-256 of file"""
    sha256 = hashlib.sha256()

    with open(filename, 'rb') as f:
        # Read file in chunks
        for chunk in iter(lambda: f.read(4096), b''):
            sha256.update(chunk)

    return sha256.hexdigest()

# Streaming hash
def sha256_stream(data_stream):
    """Hash data from stream"""
    sha256 = hashlib.sha256()

    for data_chunk in data_stream:
        sha256.update(data_chunk)

    return sha256.hexdigest()
```

### Manual Implementation (Educational)

```python
def rotr(n, b):
    """Rotate right"""
    return ((n >> b) | (n << (32 - b))) & 0xFFFFFFFF

def sha256_manual(message):
    """Manual SHA-256 implementation (educational)"""
    # Initialize hash values
    h = [
        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    ]

    # Initialize round constants
    k = [
        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
        # ... (64 constants total)
    ]

    # Padding
    msg_len = len(message) * 8
    message += b'\x80'  # Append '1' bit
    while (len(message) * 8) % 512 != 448:
        message += b'\x00'
    message += msg_len.to_bytes(8, 'big')  # Append length

    # Process each 512-bit block
    for block_start in range(0, len(message), 64):
        block = message[block_start:block_start + 64]

        # Create message schedule
        w = list(int.from_bytes(block[i:i+4], 'big') for i in range(0, 64, 4))
        for i in range(16, 64):
            s0 = rotr(w[i-15], 7) ^ rotr(w[i-15], 18) ^ (w[i-15] >> 3)
            s1 = rotr(w[i-2], 17) ^ rotr(w[i-2], 19) ^ (w[i-2] >> 10)
            w.append((w[i-16] + s0 + w[i-7] + s1) & 0xFFFFFFFF)

        # Initialize working variables
        a, b, c, d, e, f, g, h_ = h

        # 64 rounds
        for i in range(64):
            S1 = rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25)
            ch = (e & f) ^ (~e & g)
            temp1 = (h_ + S1 + ch + k[i] + w[i]) & 0xFFFFFFFF
            S0 = rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22)
            maj = (a & b) ^ (a & c) ^ (b & c)
            temp2 = (S0 + maj) & 0xFFFFFFFF

            h_ = g
            g = f
            f = e
            e = (d + temp1) & 0xFFFFFFFF
            d = c
            c = b
            b = a
            a = (temp1 + temp2) & 0xFFFFFFFF

        # Update hash values
        h = [(x + y) & 0xFFFFFFFF for x, y in zip(h, [a,b,c,d,e,f,g,h_])]

    # Produce final hash
    return ''.join(f'{x:08x}' for x in h)

# Test
print(sha256_manual(b"abc"))
# Should output: ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad
```

### Node.js Implementation

```javascript
const crypto = require('crypto');

function sha256(message) {
    return crypto.createHash('sha256')
                 .update(message)
                 .digest('hex');
}

// Usage
console.log(sha256('Hello, World!'));

// File hashing
const fs = require('fs');

function sha256File(filename) {
    return new Promise((resolve, reject) => {
        const hash = crypto.createHash('sha256');
        const stream = fs.createReadStream(filename);

        stream.on('data', chunk => hash.update(chunk));
        stream.on('end', () => resolve(hash.digest('hex')));
        stream.on('error', reject);
    });
}

// Usage
sha256File('document.pdf').then(hash => {
    console.log('File SHA-256:', hash);
});
```

## Security Properties

### Collision Resistance

**Birthday Paradox**: Need ~2^128 attempts to find collision

```
Probability of collision after n hashes:
P(collision) ≈ n² / (2 × 2^256) ≈ n² / 2^257
```

For 50% probability: n ≈ 2^128

**Conclusion**: SHA-256 is collision-resistant in practice

### Pre-image Resistance

Finding input M such that SHA-256(M) = H requires ~2^256 attempts

**Brute force example**:
```python
import hashlib
import itertools

def find_preimage(target_hash, max_attempts=1000000):
    """Try to find pre-image (will fail for real hashes)"""
    for i in range(max_attempts):
        candidate = f"message_{i}".encode()
        if hashlib.sha256(candidate).hexdigest() == target_hash:
            return candidate
    return None
```

### Avalanche Effect

Small change in input → ~50% bits change in output:

```python
def demonstrate_avalanche():
    """Show avalanche effect"""
    msg1 = "Hello, World!"
    msg2 = "Hello, World."  # Changed one character

    hash1 = hashlib.sha256(msg1.encode()).hexdigest()
    hash2 = hashlib.sha256(msg2.encode()).hexdigest()

    # Count different bits
    diff_bits = bin(int(hash1, 16) ^ int(hash2, 16)).count('1')

    print(f"Hash 1: {hash1}")
    print(f"Hash 2: {hash2}")
    print(f"Different bits: {diff_bits} / 256 ({diff_bits/256*100:.1f}%)")

demonstrate_avalanche()
# Output: ~128 bits different (50%)
```

## Real-World Applications

### Bitcoin Mining

```python
import hashlib
import time

def bitcoin_mine(block_data, target_zeros=4):
    """Simplified Bitcoin mining"""
    nonce = 0
    target = '0' * target_zeros

    start = time.time()
    while True:
        block = f"{block_data}{nonce}".encode()
        hash_result = hashlib.sha256(hashlib.sha256(block).digest()).hexdigest()

        if hash_result.startswith(target):
            elapsed = time.time() - start
            print(f"Block mined! Nonce: {nonce}, Hash: {hash_result}")
            print(f"Time: {elapsed:.2f}s, Hashes: {nonce}")
            return nonce, hash_result

        nonce += 1

# Mine a block
bitcoin_mine("Block #12345: Alice -> Bob: 1 BTC", target_zeros=5)
```

### File Integrity Verification

```python
def verify_file_integrity(filename, expected_hash):
    """Verify file hasn't been tampered with"""
    computed_hash = sha256_file(filename)

    if computed_hash == expected_hash:
        print(f"✓ File integrity verified: {filename}")
        return True
    else:
        print(f"✗ WARNING: File tampered! {filename}")
        print(f"  Expected: {expected_hash}")
        print(f"  Got:      {computed_hash}")
        return False

# Example: Verify downloaded file
verify_file_integrity(
    'ubuntu-22.04.iso',
    'a4acfda10b18da50e2ec50ccaf860d7f20b389df8765611142305c0e911d16fd'
)
```

### Password Hashing (with PBKDF2)

```python
import hashlib
import os

def hash_password_sha256(password, salt=None, iterations=100000):
    """Hash password using PBKDF2-HMAC-SHA256"""
    if salt is None:
        salt = os.urandom(16)

    key = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, iterations)
    return salt + key

# Usage (for password storage, use Argon2 instead!)
hashed = hash_password_sha256("MyPassword123")
```

### Digital Signatures

```python
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import ec

def sign_message(message, private_key):
    """Sign message hash with ECDSA"""
    # Hash message first
    digest = hashlib.sha256(message.encode()).digest()

    # Sign the hash
    signature = private_key.sign(digest, ec.ECDSA(hashes.SHA256()))
    return signature
```

## Performance Characteristics

### Benchmarks

| Platform | Throughput |
|----------|------------|
| **Software (Python)** | ~100 MB/s |
| **Software (C)** | ~300-500 MB/s |
| **Hardware (AES-NI)** | ~1-3 GB/s |
| **GPU (CUDA)** | ~10-50 GB/s |
| **ASIC (Bitcoin)** | ~100+ TH/s |

### Optimization Tips

```python
import hashlib

# Efficient for multiple updates
sha256 = hashlib.sha256()
sha256.update(b"part 1")
sha256.update(b"part 2")
result = sha256.hexdigest()

# Reuse hash object state (copy before digest)
original = hashlib.sha256(b"prefix")
hash1 = original.copy()
hash1.update(b"data1")
hash2 = original.copy()
hash2.update(b"data2")
```

## SHA-256 vs Alternatives

| Algorithm | Output | Speed | Security | Use Case |
|-----------|--------|-------|----------|----------|
| **SHA-256** | 256-bit | Fast | Excellent | General purpose |
| **SHA-512** | 512-bit | Medium | Higher | High security |
| **SHA-3-256** | 256-bit | Medium | Excellent | New standard |
| **BLAKE2b** | Variable | Very Fast | Excellent | High performance |
| **MD5** | 128-bit | Very Fast | **BROKEN** | ❌ Never use |
| **SHA-1** | 160-bit | Fast | **WEAK** | ❌ Deprecated |

## Best Practices

1. ✅ **Use SHA-256 for**: Integrity checks, digital signatures, blockchain
2. ✅ **Always use with salt** for password hashing
3. ✅ **Use HMAC-SHA256** for authentication (not plain SHA-256)
4. ✅ **Verify file downloads** using published SHA-256 hashes
5. ✅ **Use hexadecimal or base64** encoding for display
6. ❌ **Don't use for passwords alone** (use Argon2/PBKDF2)
7. ❌ **Don't truncate hashes** (use full 256 bits)
8. ❌ **Don't use MD5 or SHA-1** (use SHA-256+)

## Conclusion

SHA-256 is a **cryptographically secure** hash function suitable for:

- **Blockchain**: Bitcoin, Ethereum transaction IDs
- **Digital Signatures**: Sign message hashes
- **File Integrity**: Verify downloads, backups
- **Certificates**: TLS/SSL certificate fingerprints
- **Git**: Commit hashes
- **Password Storage**: With PBKDF2/Argon2 (not alone)

**Key Properties**:
- 256-bit output (64 hex characters)
- Collision-resistant
- Pre-image resistant
- Fast computation
- Widely supported

**Use SHA-256 as the default hash function for modern applications!**
